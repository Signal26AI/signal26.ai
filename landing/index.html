<!-- Inspired by the generative art of Rafael Rozendaal -->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background: #000; }
canvas { display: block; width: 100%; height: 100%; }
#tap-enter { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: white; opacity: 0.3; font: 1.2rem sans-serif; letter-spacing: 0.3em;
  text-transform: uppercase; pointer-events: none; z-index: 10;
  transition: opacity 1s ease; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
</head>
<body>
<canvas></canvas>
<div id="tap-enter">tap to enter</div>
<script>
const cvs = document.querySelector('canvas');
const ctx = cvs.getContext('2d');

const pairs = [
  ['#ff0000','#0000ff'],['#00ffff','#ff00ff'],['#ffff00','#00ff00'],
  ['#ff00ff','#ffff00'],['#0000ff','#00ffff'],['#ff0000','#00ff00'],
  ['#ffffff','#000000'],['#ed1e79','#29abe2'],['#7100bf','#00ffff'],
  ['#ff9900','#662d91']
];

let w, h, dpr;
let currentPair, nextPair, fadeProgress = 1, fadeSpeed = 0.003;
let pairIndex = 0;
const gradientSteps = 12;

function lerpColor(a, b, t) {
  const ah = parseInt(a.slice(1), 16), bh = parseInt(b.slice(1), 16);
  const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
  const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
  const r = Math.round(ar + (br - ar) * t);
  const g = Math.round(ag + (bg - ag) * t);
  const b2 = Math.round(ab + (bb - ab) * t);
  return '#' + ((r << 16) + (g << 8) + b2).toString(16).padStart(6, '0');
}

function easeInOut(t) { return t * t * (3 - 2 * t); }

function pickNext() {
  let idx;
  do { idx = Math.floor(Math.random() * pairs.length); } while (idx === pairIndex);
  pairIndex = idx;
  return pairs[idx];
}

function startFade() {
  currentPair = nextPair || pairs[0];
  nextPair = pickNext();
  fadeProgress = 0;
}

function resize() {
  dpr = window.devicePixelRatio || 1;
  w = window.innerWidth; h = window.innerHeight;
  cvs.width = w * dpr; cvs.height = h * dpr;
  cvs.style.width = w + 'px'; cvs.style.height = h + 'px';
}

function draw() {
  fadeProgress = Math.min(1, fadeProgress + fadeSpeed);
  const t = easeInOut(fadeProgress);
  const c0 = lerpColor(currentPair[0], nextPair[0], t);
  const c1 = lerpColor(currentPair[1], nextPair[1], t);

  const cx = w * dpr / 2, cy = h * dpr / 2;
  const r = Math.hypot(w, h) * dpr * 0.5;

  const ratios = [];
  for (let i = 0; i <= gradientSteps; i++) {
    const p = easeInOut(i / gradientSteps);
    ratios.push(p * 0.2 + (1 - p) * 0 + p * 0.8);
  }

  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
  for (let i = 0; i <= gradientSteps; i++) {
    const st = i / gradientSteps;
    const col = lerpColor(c0, c1, st);
    grad.addColorStop(easeInOut(st), col);
  }
  grad.addColorStop(1, '#000000');

  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, cvs.width, cvs.height);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, cvs.width, cvs.height);

  if (fadeProgress >= 1) startFade();
  requestAnimationFrame(draw);
}

window.addEventListener('resize', resize);
resize();
currentPair = pairs[0];
nextPair = pickNext();
fadeProgress = 0;
draw();

// — Generative ambient soundtrack (2001/Ligeti inspired) —
let audioStarted = false;
document.addEventListener('click', async () => {
  if (audioStarted) return;
  audioStarted = true;
  document.getElementById('tap-enter').style.opacity = '0';
  setTimeout(() => document.getElementById('tap-enter').remove(), 1200);
  await Tone.start();

  const rev = new Tone.Reverb({ decay: 12, wet: 0.85 }).toDestination();
  const filt = new Tone.Filter({ frequency: 300, type: 'lowpass', rolloff: -24 }).connect(rev);
  const master = new Tone.Gain(0.18).connect(filt);

  // Drone oscillators — detuned for beating
  const freqs = [55, 82.5, 110, 147];
  const types = ['sine', 'triangle', 'sine', 'triangle'];
  const oscs = freqs.map((f, i) => {
    const o = new Tone.Oscillator({ frequency: f + (Math.random() - 0.5) * 2,
      type: types[i], volume: -24 - i * 3 }).connect(master);
    o.start();
    return o;
  });

  // Slow LFOs for filter and volume drift
  const filtLFO = new Tone.LFO({ frequency: 0.02 + Math.random() * 0.01,
    min: 120, max: 600, type: 'sine' }).connect(filt.frequency).start();
  const volLFO = new Tone.LFO({ frequency: 0.015 + Math.random() * 0.01,
    min: -6, max: 0, type: 'sine' }).connect(master.gain).start();

  // Slow detune drift — never repeats exactly
  setInterval(() => {
    oscs.forEach(o => {
      o.frequency.rampTo(o.frequency.value + (Math.random() - 0.5) * 4, 10);
    });
    filtLFO.frequency.rampTo(0.015 + Math.random() * 0.025, 8);
  }, 8000);

  // Occasional high harmonic overtones (Ligeti clusters)
  const overtoneRev = new Tone.Reverb({ decay: 8, wet: 0.9 }).toDestination();
  function spawnOvertone() {
    const freq = 800 + Math.random() * 3200;
    const osc = new Tone.Oscillator({ frequency: freq, type: 'sine', volume: -36 })
      .connect(overtoneRev);
    osc.start();
    osc.volume.rampTo(-28, 4 + Math.random() * 6);
    setTimeout(() => {
      osc.volume.rampTo(-Infinity, 5 + Math.random() * 8);
      setTimeout(() => { osc.stop(); osc.dispose(); }, 14000);
    }, 5000 + Math.random() * 10000);
    setTimeout(spawnOvertone, 6000 + Math.random() * 18000);
  }
  setTimeout(spawnOvertone, 3000);
}, { once: true });
</script>
</body>
</html>
